# Binary Tree and Binary Search Tree

[binary tree and binary search tree](https://www.youtube.com/watch?v=EPwWrs8OtfI)

# Binary Tree

## Definition:

- A binary tree is a tree where each node has at most 2 children:
    - left child
    - right child

## Basic Node Structure:

```cpp
struct Node {
    int val;
    Node* left;
    Node* right;
};
```

## Types of Binary Trees

1. Full Binary Tree
    - Every node has 0 or 2 children.

2. Perfect Binary Tree
    - Every internal node has 2 children and all leaves are at the same level.

3. Complete Binary Tree
    - All levels are filled except possibly the last; last level filled left to right.

4. Balanced Binary Tree
    - Height is O(log n).

5. Binary Search Tree (BST)
    - Left < root < right for every node.

## Tree Traversals

1. Preorder (Process Root → Left → Right)

    - Use case: copy/serialize tree

```cpp
visit(root)
preorder(left)
preorder(right)
```

2. Inorder (Process Left → Root → Right)
    - Use case: sorted output for BST

```cpp
inorder(left)
visit(root)
inorder(right)
```

3. Postorder (Process Left → Right → Root)
    - Use case: deleting a tree

```cpp
post(left)
post(right)
visit(root)
```

4. Level Order (BFS)
    - Use case: shortest path in tree

```cpp
Use a queue
Visit level by level
```

## Height of a Binary Tree 

    - Height = number of edges on the longest path from root to leaf.
    - Recursive formula: height = 1 + max(height(left), height(right))

## Time complexity

(General Binary Trees)

    -       	Average	Worst
    - Search	O(n)	O(n)
    - Insert	O(n)	O(n)
    - Delete	O(n)	O(n)

(Balanced Trees, e.g., AVL/Red-Black/BST):

    -     	    Time
    - Search	O(log n)
    - Insert	O(log n)
    - Delete	O(log n)

## Properties

    - A tree with height h has at most 2^(h+1) − 1 nodes
    - A perfect tree of height h has exactly 2ᵏ nodes at level k
    - Leaves ≥ Internal nodes + 1 (full binary tree property)

# Binary Search Tree

## Definition:

    - A Binary Search Tree is a binary tree where every node follows the BST property: left subtree  <  root  <  right subtree
    - All values in the left subtree are smaller
    - All values in the right subtree are greater
    - No duplicates (in classic BST)
    - This property allows fast searching

```cpp
Node Structure (Concept)
struct Node {
    int val;
    Node* left;
    Node* right;
};
```

## BST Property

    - For any node: max(left subtree)   <   node value   <   min(right subtree)

    - This must hold recursively for every node.

## Operations on BST

1. Search
    - Compare target with root
    - If smaller → go left
    - If bigger → go right
    - If equal → found

    - Time:
    - Average: O(log n)
    - Worst: O(n) (degenerate tree / skewed)

2. Insert

    - Search for the correct position
    - Insert new node where null is found
    - Time:
    - Same as search → O(log n) average

3. Delete
    - Three cases:
        1. Node has no children → remove directly
        2. Node has one child → replace node with child
        3. Node has two children → replace with
            - inorder successor (smallest in right subtree) or
            - inorder predecessor (largest in left subtree)

    - Time:
        - O(log n) average
        - O(n) worst

## Traversals in BST

    1. Inorder Traversal → Sorted Output
        - Left → Root → Right
    - This always gives elements in ascending order.

    2. Preorder / Postorder
        - Same as binary tree, but used for:
            - copying
            - deleting
            - constructing from orders

## Time Complexity (BST)

    - Operation	    Average	    Worst
    - Search	    O(log n)	O(n)
    - Insert	    O(log n)	O(n)
    - Delete	    O(log n)	O(n)

    - Worst case happens when the tree is unbalanced, like inserting sorted data.

## Balanced vs Unbalanced BST

### Unbalanced BST

    - Height = n → bad performance.
    - Looks like a linked list:

```cpp
1
 \
  2
   \
    3
     \
      4
```

### Balanced BST

- Fast performance.
- Height is log n

```cpp

      8
    /   \
   4     12
  / \   /  \
 2  6 10  14
```

- Balanced BST examples: AVL or Red-Black Tree

## When to Use a BST

    - Dynamic data where you need:
        - fast insert
        - fast delete
        - fast search

    - Sorted traversal (inorder)
    - Range queries (find values between L and R)
