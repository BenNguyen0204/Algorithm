# Divide and Conquere

## Definition:

- Divide and Conquer is an algorithmic technique where you solve a problem by:
    1. Divide → split problem into smaller subproblems
    2. Conquer → solve each subproblem (usually recursively)
    3. Combine → merge solutions into a final answer


## General Template:

```cpp
function solve(problem):
    if problem is small:
        return answer

    divide problem into smaller subproblems

    leftAns  = solve(left part)
    rightAns = solve(right part)

    return combine(leftAns, rightAns)
```

## Master Theorem for Time Complexity:

- a = number of subproblems
- n/b = size of each subproblem
- O(n<sup>d</sup>) = extra work outside recursion

[masterTheorem](MasterTheorem.png)

## Pros and Cons and when to use

**Pros:**

    - Solves problems faster than brute force
    - Easy to analyze time complexity
    - Structure is clean and reusable

**Cons:**

    - May use extra memory (merge sort)
    - Recursion overhead
    - Worst-case can be bad without care (quicksort)

**Use it when:**

    - Problems naturally split in half
    - You want O(n log n) performance


## Example: Multiplying large binary numbers:

- Goal: Multiply two n bit binary numbers

### Naive method:

    - Perform long multiplication, take O(n<sup>2</sup>)

### DNC method:
    - Split each number into halves:
        - A = A1 A0     // high half and low half
        - B = B1 B0
    - We have:
    
    [MultiplyDc](MultiplyDc.png)

```cpp
function multiply(A, B):
    Input: n-bit integers A and B
    Output: A * B

    if n == 1: return A * B

    // Split into halves
    // A = A1 A0
    A1 = high n/2 bits of A
    A0 = low  n/2 bits of A

    // A = B1 B0
    B1 = high n/2 bits of B
    B0 = low  n/2 bits of B

    // 4 recursive products
    P1 = multiply(A1, B1)   // high × high
    P2 = multiply(A1, B0)   // high × low
    P3 = multiply(A0, B1)   // low  × high
    P4 = multiply(A0, B0)   // low  × low

    // Combine the parts
    return P1 * 2^n + (P2 + P3) * 2^(n/2) + P4
```

**Time Complexity**

- One top level, base case: work on n bits, takes cn time
    - You split A and B → O(n)
        - Sperate A into A1, A0, read first n/2 and last n/2 => O(n)
    - You add/shift/merge → O(n)
    - You call recursion 4 times
    => c(n) times
-Level 1: (4 recursive calls)
    - Works on  n/2 bits, each cost c(n/2) times
    => 4 * c(n/2) = 2cn times
-Level 2: (each of the 4 nodes splits again)
    - Works on  n/4 bits, each cost c(n/4) times
    => 16* c(n/4) = 4cn times

=> Sum of geometric series: cn(1+2+4+...+2<sup>logn</sup>) = cn(2n-1) = O(n<sup>2</sup>)